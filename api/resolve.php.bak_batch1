<?php
declare(strict_types=1);

require_once __DIR__ . '/../includes/content/versioncomparator.php';
require_once __DIR__.'/../includes/Core/ConflictResolutionService.php';

header('Content-Type: application/json');

/**
 * @OA\Post(
 *     path="/api/resolve",
 *     summary="Resolve content version conflicts",
 *     @OA\RequestBody(
 *         required=true,
 *         @OA\JsonContent(
 *             required={"version_a", "version_b"},
 *             @OA\Property(property="version_a", type="object", description="Original version"),
 *             @OA\Property(property="version_b", type="object", description="New version"),
 *             @OA\Property(property="auto_merge", type="boolean", description="Attempt automatic merge")
 *         )
 *     ),
 *     @OA\Response(
 *         response=200,
 *         description="Conflict resolution result",
 *         @OA\JsonContent(
 *             @OA\Property(property="status", type="string"),
 *             @OA\Property(property="data", type="object"),
 *             @OA\Property(property="error", type="string", nullable=true)
 *         )
 *     )
 * )
 */
function handleRequest(): void {
    try {
        // Verify request method
        if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
            throw new RuntimeException('Only POST requests are accepted', 405);
        }

        // Get and validate input
        $input = json_decode(file_get_contents('php://input'), true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            throw new RuntimeException('Invalid JSON input', 400);
        }

        if (!isset($input['version_a']) || !isset($input['version_b'])) {
            throw new RuntimeException('Missing required version data', 400);
        }

        // Authenticate (placeholder - implement actual auth)
        if (!authenticateRequest()) {
            throw new RuntimeException('Unauthorized', 401);
        }

        // Log request
        logResolutionAttempt($input);

        // Process conflict resolution
        $result = processConflictResolution($input);

        // Return success response
        echo json_encode([
            'status' => 'success',
            'data' => $result
        ]);
    } catch (Throwable $e) {
        // Error handling
        http_response_code($e->getCode() >= 400 ? $e->getCode() : 500);
        echo json_encode([
            'status' => 'error',
            'error' => $e->getMessage()
        ]);
    }
}

function authenticateRequest(): bool {
    // TODO: Implement actual authentication
    return true;
}

function logResolutionAttempt(array $input): void {
    // TODO: Implement proper logging
    file_put_contents(
        __DIR__.'/../logs/resolution.log',
        date('Y-m-d H:i:s').' - Resolution attempt: '.json_encode($input).PHP_EOL,
        FILE_APPEND
    );
}

function processConflictResolution(array $input): array {
    $versionA = $input['version_a'];
    $versionB = $input['version_b'];
    $autoMerge = $input['auto_merge'] ?? false;

    $conflictInfo = ConflictResolutionService::detectConflicts($versionA, $versionB);

    if (!$conflictInfo['has_conflict']) {
        return [
            'resolution_type' => 'no_conflict',
            'result' => $versionB
        ];
    }

    if ($autoMerge && $conflictInfo['automatic_merge_possible']) {
        return [
            'resolution_type' => 'auto_merged',
            'result' => ConflictResolutionService::autoMerge($versionA, $versionB),
            'conflicts_resolved' => $conflictInfo['conflicting_fields']
        ];
    }

    return [
        'resolution_type' => 'manual_resolution_required',
        'conflicts' => $conflictInfo['conflicting_fields'],
        'diff' => $conflictInfo['diff']
    ];
}

handleRequest();
