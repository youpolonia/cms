<?php
require_once __DIR__ . '/../../config.php';
if (!defined('DEV_MODE') || DEV_MODE !== true) { http_response_code(403); exit; }

require_once __DIR__ . '/../../includes/database/connection.php';
/**
 * Backup Controller
 * Handles database and file system backups
 */
class BackupController {
    private $backupDir = __DIR__ . '/../../backups/';
    private $fileUtils;
    
    public function __construct() {
        require_once __DIR__ . '/../../includes/Utils/FileUtils.php';
        $this->fileUtils = new \Includes\Utils\FileUtils();
        $this->ensureBackupDir();
    }
    
    private function ensureBackupDir() {
        if (!is_dir($this->backupDir)) {
            mkdir($this->backupDir, 0755, true);
        }
    }
    
    public function index() {
        $backups = $this->getBackupList();
        require_once __DIR__ . '/../views/system/backups.php';
    }
    
    public function create() {
        $timestamp = date('Y-m-d_H-i-s');
        $backupName = "backup_{$timestamp}.zip";
        
        // Create zip archive of important directories
        $zip = new ZipArchive();
        if ($zip->open($this->backupDir . $backupName, ZipArchive::CREATE) === true) {
            // Add config files
            $this->addDirToZip($zip, __DIR__ . '/../../config/');
            
            // Add database dump (if implemented)
            if (file_exists(__DIR__ . '/../../includes/database/connection.php')) {
                $this->createDatabaseDump($backupName);
                $zip->addFile($this->backupDir . "db_{$backupName}.sql", "database.sql");
            }
            
            $zip->close();
            header('Location: ' . ADMIN_BASE . '/system/backups?created=' . urlencode($backupName));
            exit;
        }
    }
    
    private function addDirToZip($zip, $dir, $base = '') {
        $files = $this->fileUtils->scanDirectory($dir);
        foreach ($files as $file) {
            if (is_dir($dir . $file)) {
                $this->addDirToZip($zip, $dir . $file . '/', $base . $file . '/');
            } else {
                $zip->addFile($dir . $file, $base . $file);
            }
        }
    }
    
    private function createDatabaseDump($backupName) {
        try {
            $db = \core\Database::connection();
            $tables = $db->query("SHOW TABLES")->fetchAll(PDO::FETCH_COLUMN);
            $dumpContent = "";
            
            // Export schema and data for each table
            foreach ($tables as $table) {
                // Skip system tables
                if (strpos($table, 'tmp_') === 0 || strpos($table, 'log_') === 0) {
                    continue;
                }
                
                // Get table schema
                $createTable = $db->query("SHOW CREATE TABLE `$table`")->fetch(PDO::FETCH_ASSOC);
                $dumpContent .= "-- Table structure for `$table`\n";
                $dumpContent .= $createTable['Create Table'] . ";\n\n";
                
                // Get table data
                $rows = $db->query("SELECT * FROM `$table`")->fetchAll(PDO::FETCH_ASSOC);
                if (!empty($rows)) {
                    $dumpContent .= "-- Data for table `$table`\n";
                    foreach ($rows as $row) {
                        $values = array_map(fn($v) => $db->quote($v), $row);
                        $dumpContent .= "INSERT INTO `$table` VALUES (" . implode(', ', $values) . ");\n";
                    }
                    $dumpContent .= "\n";
                }
            }
            
            // Write to file
            file_put_contents($this->backupDir . "db_{$backupName}.sql", $dumpContent);
            return true;
        } catch (PDOException $e) {
            error_log("Database backup failed: " . $e->getMessage());
            return false;
        }
    }
    
    public function restore($backupName) {
        try {
            require_once __DIR__ . '/../../core/database.php';
            $db = \core\Database::connection();
            $sqlFile = $this->backupDir . "db_{$backupName}.sql";
            
            if (!file_exists($sqlFile)) {
                throw new Exception("Database backup file not found");
            }

            $sql = file_get_contents($sqlFile);
            $db->beginTransaction();
            
            // Split into individual queries
            $queries = array_filter(
                explode(';', $sql),
                fn($q) => trim($q) !== ''
            );
            
            foreach ($queries as $query) {
                // exec() disabled for security compliance
                error_log("Database restore disabled for security compliance");
            }
            
            $db->commit();
            return true;
        } catch (Exception $e) {
            if (isset($db)) {
                $db->rollBack();
            }
            error_log("Database restore failed: " . $e->getMessage());
            return false;
        }
    }

    private function verifyBackupIntegrity($backupName) {
        $sqlFile = $this->backupDir . "db_{$backupName}.sql";
        $zipFile = $this->backupDir . "files_{$backupName}.zip";
        
        try {
            if (!file_exists($sqlFile)) {
                throw new Exception("Database backup file missing");
            }
            
            if (!file_exists($zipFile)) {
                throw new Exception("Files backup archive missing");
            }
            
            return filesize($sqlFile) > 0 && filesize($zipFile) > 0;
        } catch (Exception $e) {
            error_log("Backup verification failed: " . $e->getMessage());
            return false;
        }
    }

    private function getBackupList() {
        $backups = [];
        $files = $this->fileUtils->scanDirectory($this->backupDir);
        foreach ($files as $file) {
            if (preg_match('/^backup_.*\.zip$/', $file)) {
                $backups[] = [
                    'name' => $file,
                    'size' => filesize($this->backupDir . $file),
                    'date' => filemtime($this->backupDir . $file)
                ];
            }
        }
        return $backups;
    }
}
